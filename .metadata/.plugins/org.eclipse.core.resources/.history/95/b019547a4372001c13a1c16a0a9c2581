package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PROG, BREAK, CLASS, ENUM, ELSE, CONST, IF, DO, WHILE, NEW, PRINT, READ;
terminal RETURN, VOID, EXTENDS, CONTINUE, THIS, SUPER, GOTO, RECORD;
terminal MINUS, PLUS, MUL, DIV, MOD, EQUAL, NOTEQ, GRT, GRTE, LESS, LESSE;
terminal AND, OR, ASSIGN, PLUSPLUS, MINUSMINUS, COLON, SEMI, COMMA, DOT;

terminal LBRACE, RBRACE, LPAREN, RPAREN, LSQUARE, RSQUARE;
terminal Integer NUMBER ;
terminal String IDENT ;
terminal Character CHAR ;
terminal String BOOL ;

nonterminal Program Program;
nonterminal Epsilon Epsilon;
nonterminal ProgList ProgList;
nonterminal MethodDeclList MethodDeclList;
nonterminal ConstDecl ConstDecl;
nonterminal ConstDeclList ConstDeclList;
nonterminal ConstType ConstType;

nonterminal VarDecl VarDecl;
nonterminal VarDeclList VarDeclList;
nonterminal ClassDecl ClassDecl;
nonterminal VarDeclListList VarDeclListList;
nonterminal ConstrMeth ConstrMeth;
nonterminal MethodDeclListList MethodDeclListList;
nonterminal RecordDecl RecordDecl;
nonterminal MethodDecl MethodDecl;
nonterminal MethDeclType MethDeclType;
nonterminal FormParsList FormParsList;
nonterminal StatementList StatementList;
nonterminal FormPars FormPars;
nonterminal Type Type;
nonterminal Statement Statement;
nonterminal SingleStatement SingleStatement;
nonterminal Statements Statements;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal ActPars ActPars;
nonterminal Condition Condition;
nonterminal CondTerm CondTerm;
nonterminal CondFact CondFact;
nonterminal Expr Expr;
nonterminal Term Term;
nonterminal Factor Factor;
nonterminal Designator Designator;
nonterminal DesignList DesignList;
nonterminal Label Label;
nonterminal Assignop Assignop;
nonterminal Relop Relop;
nonterminal Addop Addop;
nonterminal Mulop Mulop;



precedence left ELSE;


Program ::= (Program) PROG IDENT:I1 ProgList:P2 LBRACE MethodDeclList:M3 RBRACE {: RESULT=new Program(I1, P2, M3); RESULT.setLine(I1left); :} ;
ProgList ::= (ProgListConstDecl) ProgList:P1 ConstDecl:C2 {: RESULT=new ProgListConstDecl(P1, C2); RESULT.setLine(P1left); :}
			|
			(ProgListVarDecl) ProgList:P1 VarDecl:V2 {: RESULT=new ProgListVarDecl(P1, V2); RESULT.setLine(P1left); :}
			|
			(ProgListClassDecl) ProgList:P1 ClassDecl:C2 {: RESULT=new ProgListClassDecl(P1, C2); RESULT.setLine(P1left); :}
			|
			(ProgListRecordDecl) ProgList:P1 RecordDecl:R2 {: RESULT=new ProgListRecordDecl(P1, R2); RESULT.setLine(P1left); :}
			|
			(ProgListNoProgList) Epsilon:E1 {: RESULT=new ProgListNoProgList(E1); RESULT.setLine(E1left); :}
			;
MethodDeclList ::= (YMethodDeclList) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new YMethodDeclList(M1, M2); RESULT.setLine(M1left); :}
				|		
				(NoMethodDeclList) Epsilon:E1 {: RESULT=new NoMethodDeclList(E1); RESULT.setLine(E1left); :}
				;



ConstDecl ::= (ConstDecl) CONST Type:T1 IDENT:I2 ASSIGN ConstType:C3 ConstDeclList:C4 SEMI {: RESULT=new ConstDecl(T1, I2, C3, C4); RESULT.setLine(T1left); :};
ConstDeclList::= (YConstDeclList) ConstDeclList:C1 COMMA IDENT:I2 ASSIGN ConstType:C3 {: RESULT=new YConstDeclList(C1, I2, C3); RESULT.setLine(C1left); :}
				|
				(NoConstDeclList) Epsilon:E1 {: RESULT=new NoConstDeclList(E1); RESULT.setLine(E1left); :}
				;
ConstType ::= (ConstTypeNumber) NUMBER:N1 {: RESULT=new ConstTypeNumber(N1); RESULT.setLine(N1left); :}
			|
			(ConstTypeChar) CHAR:C1 {: RESULT=new ConstTypeChar(C1); RESULT.setLine(C1left); :}
			|
			(ConstTypeBool) BOOL:B1 {: RESULT=new ConstTypeBool(B1); RESULT.setLine(B1left); :}
		
			;



VarDecl ::= (VarDeclSquare) Type:T1 IDENT:I2 LSQUARE RSQUARE VarDeclList:V3 SEMI {: RESULT=new VarDeclSquare(T1, I2, V3); RESULT.setLine(T1left); :}
			|
			(VarDeclNoSquare) Type:T1 IDENT:I2 VarDeclList:V3 SEMI {: RESULT=new VarDeclNoSquare(T1, I2, V3); RESULT.setLine(T1left); :}
			;
VarDeclList ::= (VarDeclListSquare) VarDeclList:V1 COMMA IDENT:I2 LSQUARE RSQUARE {: RESULT=new VarDeclListSquare(V1, I2); RESULT.setLine(V1left); :} 
			| 
			(VarDeclListNoSquare) VarDeclList:V1 COMMA IDENT:I2 {: RESULT=new VarDeclListNoSquare(V1, I2); RESULT.setLine(V1left); :} 
			|
			(NoVarDeclList) Epsilon:E1 {: RESULT=new NoVarDeclList(E1); RESULT.setLine(E1left); :}
			;




ClassDecl ::= (ClassDeclType) CLASS IDENT:I1 EXTENDS Type:T2 LBRACE VarDeclListList:V3 ConstrMeth:C4 RBRACE {: RESULT=new ClassDeclType(I1, T2, V3, C4); RESULT.setLine(I1left); :}
			|
			(ClassDeclNoType) CLASS IDENT:I1 LBRACE VarDeclListList:V2 ConstrMeth:C3 RBRACE {: RESULT=new ClassDeclNoType(I1, V2, C3); RESULT.setLine(I1left); :}
			;
VarDeclListList::=  (YVarDeclListList) VarDeclListList:V1 VarDecl:V2 {: RESULT=new YVarDeclListList(V1, V2); RESULT.setLine(V1left); :}
				|
				(NoVarDeclListList) Epsilon:E1 {: RESULT=new NoVarDeclListList(E1); RESULT.setLine(E1left); :}
				;
ConstrMeth ::= (ConstrMethNoConstr) LBRACE MethodDeclListList:M1 RBRACE {: RESULT=new ConstrMethNoConstr(M1); RESULT.setLine(M1left); :} 
				|
				(NoConstrMeth) Epsilon:E1 {: RESULT=new NoConstrMeth(E1); RESULT.setLine(E1left); :}
				;
MethodDeclListList ::= (YMethodDeclListList) MethodDeclListList:M1 MethodDecl:M2 {: RESULT=new YMethodDeclListList(M1, M2); RESULT.setLine(M1left); :}
					|
					(NoMethodDeclListList) Epsilon:E1 {: RESULT=new NoMethodDeclListList(E1); RESULT.setLine(E1left); :}
					;
	
	
	
	
RecordDecl ::= (RecordDecl) RECORD IDENT:I1 LBRACE VarDeclListList:V2 RBRACE {: RESULT=new RecordDecl(I1, V2); RESULT.setLine(I1left); :};



				





MethodDecl ::= (MethodDecl) MethDeclType:M1 IDENT:I2 LPAREN FormParsList:F3 RPAREN VarDeclListList:V4 LBRACE StatementList:S5 RBRACE {: RESULT=new MethodDecl(M1, I2, F3, V4, S5); RESULT.setLine(M1left); :};
MethDeclType::= (MethDeclTypeType) Type:T1 {: RESULT=new MethDeclTypeType(T1); RESULT.setLine(T1left); :}
				|
				(MethDeclTypeVoid) VOID {: RESULT=new MethDeclTypeVoid(); :}
				;
FormParsList ::= (YFormParsList) FormPars:F1 {: RESULT=new YFormParsList(F1); RESULT.setLine(F1left); :}
				| 
				(NoFormParsList) Epsilon:E1 {: RESULT=new NoFormParsList(E1); RESULT.setLine(E1left); :}
				;
StatementList ::= (YStatementList) StatementList:S1 Statement:S2 {: RESULT=new YStatementList(S1, S2); RESULT.setLine(S1left); :}
				| 
				(NoStatementList) Epsilon:E1 {: RESULT=new NoStatementList(E1); RESULT.setLine(E1left); :}
				;




FormPars ::= (FormParsSquare)Type:T1 IDENT:I2 LSQUARE RSQUARE {: RESULT=new FormParsSquare(T1, I2); RESULT.setLine(T1left); :}
			|
			(FormParsNoSquare) Type:T1 IDENT:I2 {: RESULT=new FormParsNoSquare(T1, I2); RESULT.setLine(T1left); :}
			|
			(FormParsSquareList) FormPars:F1 COMMA Type:T2 IDENT:I3 LSQUARE RSQUARE {: RESULT=new FormParsSquareList(F1, T2, I3); RESULT.setLine(F1left); :}
			|
			(FormParsNoSquareList) FormPars:F1 COMMA Type:T2 IDENT:I3 {: RESULT=new FormParsNoSquareList(F1, T2, I3); RESULT.setLine(F1left); :}
			;



Type ::= (Type)IDENT:I1 {: RESULT=new Type(I1); RESULT.setLine(I1left); :};



Statement ::= (StatementStat) Statements:S1 {: RESULT=new StatementStat(S1); RESULT.setLine(S1left); :}
			|
			(StatementLab)Label:L1 COLON SingleStatement:S2 {: RESULT=new StatementLab(L1, S2); RESULT.setLine(L1left); :}
			|
			(StatementSingle)SingleStatement:S1 {: RESULT=new StatementSingle(S1); RESULT.setLine(S1left); :}
			;



SingleStatement::= (SingleStatementDesi) DesignatorStatement:D1 SEMI {: RESULT=new SingleStatementDesi(D1); RESULT.setLine(D1left); :}
					|
					(SingleStatementIfElse) IF LPAREN Condition:C1 RPAREN Statement:S2 ELSE Statement:S3 {: RESULT=new SingleStatementIfElse(C1, S2, S3); RESULT.setLine(C1left); :}
					|
					(SingleStatementIf) IF LPAREN Condition:C1 RPAREN Statement:S2 {: RESULT=new SingleStatementIf(C1, S2); RESULT.setLine(C1left); :}
					|
					(SingleStatementDo) DO Statement:S1 WHILE LPAREN Condition:C2 RPAREN SEMI {: RESULT=new SingleStatementDo(S1, C2); RESULT.setLine(S1left); :}
					|
					(SingleStatementBreak) BREAK SEMI {: RESULT=new SingleStatementBreak(); :}
					|
					(SingleStatementContinue) CONTINUE SEMI {: RESULT=new SingleStatementContinue(); :}
					|
					(SingleStatementRetExpr) RETURN Expr:E1 SEMI {: RESULT=new SingleStatementRetExpr(E1); RESULT.setLine(E1left); :}
					|
					(SingleStatementRet) RETURN SEMI {: RESULT=new SingleStatementRet(); :}
					|
					(SingleStatementRead) READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new SingleStatementRead(D1); RESULT.setLine(D1left); :}
					|
					(SingleStatementPrintNum) PRINT LPAREN Expr:E1 COMMA NUMBER:N2 RPAREN SEMI {: RESULT=new SingleStatementPrintNum(E1, N2); RESULT.setLine(E1left); :}
					|
					(SingleStatementPrint) PRINT LPAREN Expr:E1 RPAREN SEMI {: RESULT=new SingleStatementPrint(E1); RESULT.setLine(E1left); :}
					|
					(SingleStatemenGoto) GOTO Label:L1 SEMI {: RESULT=new SingleStatemenGoto(L1); RESULT.setLine(L1left); :}
					;
					




Statements ::= (Statements) LBRACE StatementList:S1 RBRACE {: RESULT=new Statements(S1); RESULT.setLine(S1left); :};

DesignatorStatement ::= (DesignatorAssignop) Designator:D1 Assignop:A2 Expr:E3 {: RESULT=new DesignatorAssignop(D1, A2, E3); RESULT.setLine(D1left); :}
						|
						(DesignatorActpars) Designator:D1 LPAREN ActPars:A2 RPAREN {: RESULT=new DesignatorActpars(D1, A2); RESULT.setLine(D1left); :}
						|
						(DesignatorParen) Designator:D1 LPAREN RPAREN {: RESULT=new DesignatorParen(D1); RESULT.setLine(D1left); :}
						|
						(DesignatorPlus) Designator:D1 PLUSPLUS {: RESULT=new DesignatorPlus(D1); RESULT.setLine(D1left); :}
						|
						(DesignatorMinus) Designator:D1 MINUSMINUS {: RESULT=new DesignatorMinus(D1); RESULT.setLine(D1left); :}
						;

						
ActPars ::= (ActParsNoList)Expr:E1 {: RESULT=new ActParsNoList(E1); RESULT.setLine(E1left); :}
			|
			(ActParsList) ActPars:A1 COMMA Expr:E2 {: RESULT=new ActParsList(A1, E2); RESULT.setLine(A1left); :}
			;

Condition ::= (ConditionNoList) CondTerm:C1 {: RESULT=new ConditionNoList(C1); RESULT.setLine(C1left); :}
			|
			(ConditionList) Condition:C1 OR CondTerm:C2 {: RESULT=new ConditionList(C1, C2); RESULT.setLine(C1left); :}
			;
CondTerm ::= (CondTermNoList) CondFact:C1 {: RESULT=new CondTermNoList(C1); RESULT.setLine(C1left); :}
			|
			(CondTermList) CondTerm:C1 AND CondFact:C2 {: RESULT=new CondTermList(C1, C2); RESULT.setLine(C1left); :}
			;
CondFact ::= (CondFactNoList) Expr:E1 {: RESULT=new CondFactNoList(E1); RESULT.setLine(E1left); :}
			|
			(CondFactList) Expr:E1 Relop:R2 Expr:E3 {: RESULT=new CondFactList(E1, R2, E3); RESULT.setLine(E1left); :}
			;
Expr ::= (ExprMin)MINUS Term:T1 {: RESULT=new ExprMin(T1); RESULT.setLine(T1left); :}
		|
		(ExprTerm) Term:T1 {: RESULT=new ExprTerm(T1); RESULT.setLine(T1left); :}
		|
		(ExprAddop) Expr:E1 Addop:A2 Term:T3 {: RESULT=new ExprAddop(E1, A2, T3); RESULT.setLine(E1left); :}
		;
Term ::= (TermFactor)Factor:F1 {: RESULT=new TermFactor(F1); RESULT.setLine(F1left); :}
		|
		(TermMlop)Term:T1 Mulop:M2 Factor:F3 {: RESULT=new TermMlop(T1, M2, F3); RESULT.setLine(T1left); :}
		;
Factor ::= (FactorDesParenAct)Designator:D1 LPAREN ActPars:A2 RPAREN {: RESULT=new FactorDesParenAct(D1, A2); RESULT.setLine(D1left); :}
			|
			(FactorDes) Designator:D1 {: RESULT=new FactorDes(D1); RESULT.setLine(D1left); :}
			|
			(FactorDesPar) Designator:D1 LPAREN RPAREN {: RESULT=new FactorDesPar(D1); RESULT.setLine(D1left); :}
			|
			(FactorNum) NUMBER:N1 {: RESULT=new FactorNum(N1); RESULT.setLine(N1left); :}
			|
			(FactorChar) CHAR:C1 {: RESULT=new FactorChar(C1); RESULT.setLine(C1left); :}
			|
			(FactorBool) BOOL:B1 {: RESULT=new FactorBool(B1); RESULT.setLine(B1left); :}
			|
			(FactorTypeExpr) NEW Type:T1 LSQUARE Expr:E2 RSQUARE {: RESULT=new FactorTypeExpr(T1, E2); RESULT.setLine(T1left); :}
			|
			(FactorType) NEW Type:T1 {: RESULT=new FactorType(T1); RESULT.setLine(T1left); :}
			|
			(FactorParen) LPAREN Expr:E1 RPAREN {: RESULT=new FactorParen(E1); RESULT.setLine(E1left); :}
			; 
Designator ::= (Designator) IDENT:I1 DesignList:D2 {: RESULT=new Designator(I1, D2); RESULT.setLine(I1left); :};
DesignList ::= (DesignListDot) DesignList:D1 DOT IDENT:I2 {: RESULT=new DesignListDot(D1, I2); RESULT.setLine(D1left); :}
			| 
			(DesignListSquare) DesignList:D1 LSQUARE Expr:E2 RSQUARE {: RESULT=new DesignListSquare(D1, E2); RESULT.setLine(D1left); :}
			|
			(NoDesignList) Epsilon:E1 {: RESULT=new NoDesignList(E1); RESULT.setLine(E1left); :}
			;
	
Label ::=(Label) IDENT:I1 {: RESULT=new Label(I1); RESULT.setLine(I1left); :};
Assignop::= (Assignop) ASSIGN {: RESULT=new Assignop(); :};
Relop ::= (RelopEqual)EQUAL {: RESULT=new RelopEqual(); :} 
		|
		(RelopNotEq) NOTEQ {: RESULT=new RelopNotEq(); :}
		|
		(RelopGrt) GRT {: RESULT=new RelopGrt(); :}
		|
		(RelopGrte) GRTE {: RESULT=new RelopGrte(); :}
		|
		(RelopLess) LESS {: RESULT=new RelopLess(); :}
		|
		(RelopLesse) LESSE {: RESULT=new RelopLesse(); :}
		;
Addop ::= (AddopPlus) PLUS {: RESULT=new AddopPlus(); :}
		|
		(AddopMinus) MINUS {: RESULT=new AddopMinus(); :}
		;
Mulop ::= (MulopMul) MUL {: RESULT=new MulopMul(); :} 
		|
		(MulopDiv) DIV {: RESULT=new MulopDiv(); :}
		|
		(MulopMod) MOD {: RESULT=new MulopMod(); :}
		;

Epsilon ::= (Epsilon) {: RESULT=new Epsilon(); :} /*epsilon */;





















