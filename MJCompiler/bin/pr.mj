//program MJProgram
	//const int a3= 5, b=7, c=8;
//	int aa[], bb,cc[];
//	class kl {int aa[], bb,cc[];}
//{
//}

program p
const int size = false;
int a;
class Table extends A{
int pos[], neg[];

{
	void putp (int a, int idx) 
	int i;
	{
	thiss[i]= true; 
	 }
void putp (int a, int idx) {
	thiss[idx].p = a; 
	thisg.bla[idx] = a; 
	return;
	 }
}
}
{}




/////////////////////////////
program p
const int size = 10;
class Table {
int pos[], neg[];
{
 void putp (int a, int idx) { thiss.pos[idx] = a; }
 void putn (int a, int idx) { thiss.neg[idx] = a; }
 int getp (int idx) { return pos[idx]; }
 int getn (int idx) { return neg[idx]; }
}
}
record Board {
int rows, columns;
}
Table val;
Board board;
{
void f(char ch, int a, int arg)
int x;
{
x = arg;
}
void main() int x, i; char c;
{




val = new Table;
val.pos = new int [size];
val.neg = new int [size];
read(x);
if(x > 5)
{
goto skip;
}
i = 0;
do{
val.putp(0, i);
 val.putn(0, i);
 i++;
}while(i<size);
skip: f(c, x, i);
board = new Board;
read(board.rows);
x = board.rows;
do{
 if(x <= 0) break;
 if (0 <= x && x < size)
{
val.putp(val.getp(x)+1);
}
else if (-size < x && x < 0)
 {
val.putn(val.getn(-x)+1);
 }
read(x);
 }while(true);
}
}
///////////////////////////////
program Program
class A{int x[],y[];}
const int pi = 3, e = 2;
class B extends A {
 int i;
 {
int getValue(int a) int b; bool c;{
 return thiss.i + thiss.x[0] + a; }
void m(){}
 }
}
class C extends B{A theA;int a;}
{
void main() A a; C c; int i; int x[]; char ch; {
a = new A;
a.x = new int[5]; a.y = new int[5];
c = new C;
c.theA = a; c.x = new int[5];
x = new int[3];
read(c.i);
i = 0;
do{
read(c.x[i]); read(c.theA.x[i]);
i++;
}while(i<5);
print(c.getValue(c.theA.x[0]));
c.m();
}
}
///////////////////////////////////
program p
	
	const int size =5 ,n='7' , b=true;
	//=; ZASTO NECE, SAMO U OVOM SLUCAJU
	
	int a, b,c;
	//=;
	int c;
	class A {}
	class B extends A{
		int a, b[];
		string s;
		{
			void putp (int a, int idx) {}
			int testingMore (int a ,double b ) float random; {
//goto ; ovo prolazi iako ne treeba


//s+;
//s=5
//= ovo je fat
//; ovo je fat
//=; ovo aje ft
//a=;
//if(d ||){bla=6;}

				random = a.fetchRandomTest() * 100 + 1;
				random++;
				//kk=*5;
				//=;
				//= ;  ovako samo kaze pogresnu liniju
				//;  ovako samo kaze pogresnu liniju
				//=; ovako samo kaze pogresnu liniju
				//ww=*5;
				if (random > 25 * 2 && random <= 1 + 50 * 2) {
					do {
						random = random - 1;
						if (WorldTime.currentTime[Today] == Late) continue;
					} while (random != 0);
					break;
					loop: do random++; while (random < 50);
				} else goto loop;
				
				print (-b[5], 10);
				return random;
			}
		}
	}
	float c, d;
	record r {}
	B testObject;
{
	void main() {
		testObject = new B[c + d];
		a = testObject.testingMore() % 10;
		b = testObject.b[5];
		
		if (a >= testObject.testingMore() - testObject.b[0] && c == d) B.putp(a, b);
		else a = help(a, b);
	}
	
	int help(int a, int b) {
	
		a = 'f' + 'u' + 'c' + 'k';
		b = 't'*'h'*'i'*'s';
		return new ItWorks[a * 5 - b];
	}
	//1. pa kada je u const prvi pogresan
	//3. ignorise svea na levo od greske
}